
var DogeChainModule = function() {
  var self = this;
  self.dogechain = require('./dogechain.lib');

  self.dogeBalance = function(from, to, message) {
    var split = message.split(' ');

    if(split[0] == '!balance' && split[1]) {
      if(to == this.opt.nick) {
        to = from;
      }
      
      var address = split[1];
      var client = this;

      if(!self.dogechain.validDogeAddress(address)) {
        client.say(to, address + ' is not a valid address.');
      }
      else {
        self.dogechain.getBalance(address, function(balance) {
          if(balance != false) {
            client.say(to, "The balance of " + address + ' is Ð' + parseFloat(balance));
          }
          else {
            client.say(to, "The balance of " + address + ' is unknown');
          }
        });
      }
    }
  };

  self.dogeValue = function(from, to, message) {
    var split = message.split(' ');

    if((split[0] == '!dogevalue' || split[0] == '!dogval') && split[1]) {
      if(to == this.opt.nick) {
        to = from;
      }
      
      
      var amount = parseFloat(split[1]);
      var client = this;

      if(!isNumber(amount)) {
        client.say(to, "That's not a valid amount..");
        return;
      }

      try {
        client.say(to, "Let me check that for you, " + from + "..");

        var bter = require('bter');
        bter.getTicker(
          {
            CURR_A: 'doge',
            CURR_B: 'btc'
          },
          function(err, result) {
            if(err || !result || !result.buy) {
              client.say(to, "I don't know, sorry..");
              return;
            }

            var options = {
              hostname: 'www.bitstamp.net',
              port: 443,
              path: '/api/ticker/',
              method: 'GET'
            };
            
            var https = require('https');
            var req = https.request(options, function(res) {
              res.setEncoding('utf8');
              res.on('data', function (chunk) {
                var obj = JSON.parse(chunk);

                if(obj.bid) {
                  client.say(to, "Ð" + amount + ' = ฿' + (amount * result.buy).toFixed(4) + ' or ' + ((amount * result.buy) * obj.bid).toFixed(3) + '$ (DOGE/BTC ' + result.buy + ', BTC/USD ' + obj.bid + ')');
                }
                else {
                  client.say(to, "I don't know, sorry..");
                }
              });
            });
            req.end();
          }
        );
      }
      catch(e) {
        console.log(e);
        client.say(to, "I don't know, sorry..");
      }
    }
  };


  /**
   * Unloads all listeners
  */
  self.unload = function(client) {
    client.removeListener('message', self.dogeBalance);
    client.removeListener('message', self.dogeValue);

    delete require.cache[require.resolve('./dogechain.lib')];
  };

  /**
   * Loads all listeners
  */
  self.load = function(client) {
    self.dogechain = require('./dogechain.lib');

    client.addListener('message', self.dogeBalance);
    client.addListener('message', self.dogeValue);
  };

};

module.exports = new DogeChainModule();

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
